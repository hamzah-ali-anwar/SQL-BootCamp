-- ğ—ªğ—¶ğ—»ğ—±ğ—¼ğ˜„ ğ—™ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€

-- Find the cumulative sum of sales for each employee.


-- Rank employees based on their sales within their department.


-- Calculate a running total of orders by order date.


-- Identify the top three salaries in each department.


-- Compute the difference between the current and previous month's sales.

-- ğ—–ğ—¼ğ—ºğ—ºğ—¼ğ—» ğ—§ğ—®ğ—¯ğ—¹ğ—² ğ—˜ğ˜…ğ—½ğ—¿ğ—²ğ˜€ğ˜€ğ—¶ğ—¼ğ—»ğ˜€ (ğ—–ğ—§ğ—˜)

-- Write a recursive CTE to generate a sequence of numbers from 1 to 100.


-- Use a CTE to find employees who directly and indirectly report to a specific manager.


-- Calculate the factorial of a number using a recursive CTE.


-- Flatten a hierarchical organization chart using a CTE.


-- Use a CTE to calculate year-over-year growth in sales.

-- ğ—ğ—¼ğ—¶ğ—»ğ˜€ (ğ—œğ—»ğ—»ğ—²ğ—¿, ğ—¢ğ˜‚ğ˜ğ—²ğ—¿, ğ—–ğ—¿ğ—¼ğ˜€ğ˜€, ğ—¦ğ—²ğ—¹ğ—³)

-- Retrieve a list of customers who have placed orders (Inner Join).


-- Find employees who have not been assigned to any projects (Left Join).


-- Get a list of projects without assigned employees (Right Join).


-- Generate all possible pairs of products (Cross Join).


-- Match employees to themselves to find pairs from the same department (Self Join).

-- ğ—¦ğ˜‚ğ—¯ğ—¾ğ˜‚ğ—²ğ—¿ğ—¶ğ—²ğ˜€

-- Find employees earning more than the average salary in their department.


-- Retrieve customers who have placed more than 5 orders.


-- List products that have never been ordered.


-- Identify the second highest salary in the company using a subquery.


-- Find departments where all employees earn above a specific threshold.

-- ğ—”ğ—´ğ—´ğ—¿ğ—²ğ—´ğ—®ğ˜ğ—² ğ—™ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€

-- Calculate the total revenue generated by each product.


-- Find the average salary in each department.


-- Count the number of orders placed by each customer.



-- Find the maximum and minimum sales for each region.


-- Calculate the standard deviation of employee salaries.

-- ğ—œğ—»ğ—±ğ—²ğ˜…ğ—¶ğ—»ğ—´ ğ—®ğ—»ğ—± ğ—£ğ—²ğ—¿ğ—³ğ—¼ğ—¿ğ—ºğ—®ğ—»ğ—°ğ—²

-- Identify queries that would benefit from indexing.


-- Compare execution plans with and without an index on a specific column.


-- Check which indexes exist on a table.


-- Optimize a slow query using indexing.


-- Write a query to update a column using an indexed lookup.

